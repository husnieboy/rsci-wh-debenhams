<?php //namespace App\Classes\JDABridge;

include_once "ebcdic.php";

class jdatelnet {
	/**
	 * telnet connection
	 *
	 * @var resource
	 */
	var $fp;
	/**
	 * IP Address of the jda telnet server
	 *
	 * @var unknown_type
	 */
	var $ip = 'jdaprod2.rgoc.com.ph';

	/**
	 * Message generated by the scripts. Can be used to return messages resulting from keystroke entries
	 *
	 * @var string
	 */
	var $message = '';
	/**
	 * Contains the data returned by the last write command with getresponse = true
	 *
	 * @var unknown_type
	 */
	var $stream = '';
	var $completeStream = '';
	var $completeKeys = '';
	/**
	 * Set to True to output all streams returned by write() where getresponse = true
	 *
	 * @var bool
	 */
	var $debugLevel = 0;
	var $screen = "";
   	var $pos = 0;
   	
   	var $timeout = 300; // set to 5 minutes
	
 
	
   	
	/**
	 * Contsructor. Establishes telnet session
	 *
	 * @param string $ip
	 * @param int $time_out
	 * @return jdatelnet
	 */
	public function __construct($ip=null,$time_out=300000){
		if(!is_null($ip)) $this->ip = $ip;
		$this->fp = fsockopen($this->ip,23);		
		if(!$this->fp){
			// did not connect so do not do anything
			echo " did not connect";
			return $this->fp;
		}
		stream_set_timeout( $this->fp, 0,$time_out);


		$this->write(chr(0xFF).chr(0xFB).chr(0x1F).chr(0xFF).chr(0xFB).
				chr(0x20).chr(0xFF).chr(0xFB).chr(0x18).chr(0xFF).chr(0xFB).
				chr(0x27).chr(0xFF).chr(0xFD).chr(0x01).chr(0xFF).chr(0xFB).
				chr(0x03).chr(0xFF).chr(0xFD).chr(0x03).chr(0xFF).chr(0xFC).
				chr(0x23).chr(0xFF).chr(0xFC).chr(0x24).chr(0xFF).chr(0xFA).
				chr(0x1F).chr(0x00).chr(0x50).chr(0x00).chr(0x18).chr(0xFF).
				chr(0xF0).chr(0xFF).chr(0xFA).chr(0x20).chr(0x00).chr(0x33).
				chr(0x38).chr(0x34).chr(0x30).chr(0x30).chr(0x2C).chr(0x33).
				chr(0x38).chr(0x34).chr(0x30).chr(0x30).chr(0xFF).chr(0xF0).
				chr(0xFF).chr(0xFA).chr(0x27).chr(0x00).chr(0xFF).chr(0xF0).
				chr(0xFF).chr(0xFA).chr(0x18).chr(0x00).chr(0x58).chr(0x54).
				chr(0x45).chr(0x52).chr(0x4D).chr(0xFF).chr(0xF0));
			
		$this->write(chr(0xFF).chr(0xFC).chr(0x01).chr(0xFF).chr(0xFC).
				chr(0x22).chr(0xFF).chr(0xFE).chr(0x05).chr(0xFF).chr(0xFC).chr(0x21),1);
				
		// clear the keystrokes logged during initialization
		$this->completeKeys = '';

		$this->keys = array(
			 'F1' => chr(27).'1'
			,'F2' => chr(27).'2'
			,'F3' => chr(27).'3'
			,'F4' => chr(27).'4'
			,'F5' => chr(27).'5'
			,'F6' => chr(27).'6'
			,'F7' => chr(27).'7'
			,'F8' => chr(27).'8'
			,'F9' => chr(27).'9'
			,'F10' => chr(27).'0'
			,'F11' => chr(27).'-'
			,'F12' => chr(27).'='
			,'F13' => chr(27).'!'
			,'F14' => chr(27).'@'
			,'F15' => chr(27).'#'
			,'F16' => chr(27).'$'
			,'F17' => chr(27).'%'
			,'F18' => chr(27).'^'
			,'F19' => chr(27).'&'
			,'F20' => chr(27).'*'
			,'F21' => chr(27).'('
			,'F22' => chr(27).')'
			,'F23' => chr(27).'_'
			,'F24' => chr(27).'+'
			,'PGUP' => chr(27).'[5~'
			,'PGDN' => chr(27).'[6~'
			,'UP' => chr(27).'[A'
			,'DOWN' => chr(27).'[B'
			,'REFRESH' => chr(27).'5'
			,'DELETE' => chr(127)
			,'TAB' => "\t"
			,'BACKTAB' => chr(27)."\t"
			,'ENTER' => "\r\n"
			,'FIELDEXIT' => chr(27).'x'
			,'1' => chr(27).'x'
			,'2' => chr(27).'x'
			,'3' => chr(27).'x'
			,'4' => chr(27).'x'
			,'5' => chr(27).'x'
			,'END' => chr(27).'x'
			);
			
		$this->keys = array_flip($this->keys);

		define('F1',chr(27).'1');
		define('F2',chr(27).'2');
		define('F3',chr(27).'3');
		define('F4',chr(27).'4');
		define('F5',chr(27).'5');
		define('F6',chr(27).'6');
		define('F7',chr(27).'7');
		define('F8',chr(27).'8');
		define('F9',chr(27).'9');
		define('F10',chr(27).'0');
		define('F11',chr(27).'-');
		define('F12',chr(27).'=');
		define('F13',chr(27).'!');
		define('F14',chr(27).'@');
		define('F15',chr(27).'#');
		define('F16',chr(27).'$');
		define('F17',chr(27).'%');
		define('F18',chr(27).'^');
		define('F19',chr(27).'&');
		define('F20',chr(27).'*');
		define('F21',chr(27).'(');
		define('F22',chr(27).')');
		define('F23',chr(27).'_');
		define('F24',chr(27).'+');
		define('PGUP',chr(27).'[5~');
		define('PGDN',chr(27).'[6~');
		define('UP',chr(27).'[A');
		define('DOWN',chr(27).'[B');
		define('REFRESH',chr(27).'5');
		define('DELETE',chr(127));
		define('TAB',"\t");
		define('ENTER',"\r\n");
		define('BACKTAB',chr(27)."\t");
		define('FIELDEXIT',chr(27)."x");
		define('1',chr(27)."x");
		define('2',chr(27)."x");
		define('3',chr(27)."x");
		define('4',chr(27)."x");
		define('5',chr(27)."x");
		define('END',chr(27)."x");
					
	}
	
	
	/**
	 * Write a 5250 data stream
	 */
	function write5250($words,$aid=ENTER,$getresponse=false,$delayresponse=0,$seekstr=null){
		$aid_row_byte = chr(FLOOR($this->pos/SCR_COLS));
		$aid_col_byte = chr($this->pos % SCR_COLS);
		
		$order_code_sba = chr(0x11);
		$data_string = "";
		if(is_array($words)){
			foreach($words as $word){
				if(is_array($word)){
					$string = myasciitoebcdic($word[0]);
					if($this->debugLvl > 1) {
						echo "converted string ";
						print_r(urlencode($string));
						echo "\n data string ";
					}
					$row_byte = chr($word[1]);
					$col_byte = chr($word[2]);
					$data_string .= $order_code_sba; // Write to Display
						$data_string .= $row_byte;
						$data_string .= $col_byte;
						$data_string .= $string;
					$aid_row_byte = $row_byte;
					$aid_col_byte = chr($word[2] + strlen($string));
				}
			}
		}
	
		
		$header="";
		$length_byte_1=chr(0);
		$length_byte_2=chr(0);
		$record_type_byte_1 = chr(0x12);
		$record_type_byte_2 = chr(0xA0);
		$flags_byte_1 = chr(0x00);
		$flags_byte_2 = chr(0x00);
		$var_rec_length = chr(0x04);
		$sna_flags = chr(0x00);
		$reserved_field = chr(0x00);
		$operation_code = chr(0x03);
		$attention_identifier = $aid;
		
		$escape_code = chr(0x04);
		$end_of_record_byte_1 = chr(0xff);
		$end_of_record_byte_2 = chr(0xef);
		
		
		$binary_string = $record_type_byte_1 . $record_type_byte_2 . $flags_byte_1 . $flags_byte_2 . $var_rec_length .$sna_flags . $reserved_field ;
		$binary_string .= $operation_code . $aid_row_byte . $aid_col_byte . $attention_identifier;
		$binary_string .= $data_string;
		$binary_string .= $end_of_record_byte_1;
		$binary_string .= $end_of_record_byte_2;
		
		$length = strlen($binary_string);
		
		
		$length_byte_1 = chr(floor($length/256));
		$length_byte_2 = chr($length%256);
		
		$binary_string = $length_byte_1 . $length_byte_2 . $binary_string;
		$this->write($binary_string,$getresponse,$delayresponse,$seekstr);
		
	}


   	// =================================================================================================
   	// =================================================================================================
    /**
     * Write a 0 padded number.
     *
     * @param date $date
     * @param bool $getresponse
     * @param bool $flushbuffer
     */
    function writePaddedDate($date, $getresponse=false, $delayresponse=0) {
    	if (is_null($date) || strlen($date) == 0) $this->write('00000000', $getresponse,$delayresponse);
		else $this->write(date('00mdy', strtotime($date)), $getresponse,$delayresponse);
    }

    function writePaddedFloat($number, $length, $getresponse=false, $delayresponse=0) {
    	$pad = '0'; $type = 's';
    	$x = "%". $pad . $length . $type;
		$this->write(sprintf($x, $number),$getresponse,$delayresponse);
    }
	
	
    /**
     * Write a 0 padded number.
     *
     * @param int $number
     * @param int $length
     * @param bool $isString     
     * @param bool $getresponse
     * @param bool $flushbuffer
     */
    function writePadded($number, $length, $isString=false, $getresponse=false, $delayresponse=0) {
    	if ($isString) { $pad = '- '; $type = 's'; } 
    	else { $pad = '0'; $type = 'd'; }
    	$x = "%". $pad . $length . $type;
		$this->write(sprintf($x, $number),$getresponse,$delayresponse);
    }	
   	// =================================================================================================
   	// =================================================================================================
	
	/**
	 * login to jda application and specify library
	 *
	 * @param string $username
	 * @param string $password
	 * @param string $env
	 * @return bool
	 */
	function login($username,$password,$env=''){
		
//		if($this->debugLevel==2) $this->write(REFRESH,true);
		
		// login
		$this->write($username."	".$password."\r\n",true,3);
		
		if($this->screenCheck('does not exist','Invalid user')){
			return false;
		} elseif($this->screenCheck('Password not correct for user profile','Invalid Password')){
			return false;
		} elseif($this->screenCheck('cannot sign on','User not allowed to sign in')){
			return false;
		} elseif($this->screenCheck('F9=Change password','Login Successful')){ // login successful
			// don't need to do anything just want to be able to see if the string exists on the stream
		} else {
			$this->message = 'Unknown error during login';
			return false;
		}

		// go past the first screen
		$this->write("\r\n",true);
		
		if($this->screenCheck('is allocated to another job')){ // message is displayed if user is already connected
			if($this->screenCheck('Press Enter to continue')){ // if user is allowed multiple users then just hit enter to continue
				$this->write("\r\n",true);
			} else {
				$this->message = "User is logged in from another device and is not allowed multiple logins.";
				return false;
			}
		}
		
		$this->write($env."\r\n",true);
		while($this->screenCheck("Press Enter to continue."))
			$this->write(ENTER,true);
		
		if($this->screenCheck('MAIN MENU','Main Menu Selected')){
			return true;
		} else {
			$this->message = "Did not reach Main menu";
			return false;
		}

	}

	/**
	 * Write to the telnet session. pass $getresponse=true if you want the results of the write operation to be written to jdatelnet::stream. Pass flushbuffer=true if you want to flush what previous keystrokes have written to the buffer. You will only need to flush the buffer it he previous keystroke did not do a getresponse
	 *
	 * @param unknown_type $str
	 * @param unknown_type $getresponse
	 * @param unknown_type $flushbuffer
	 */
	function write($str,$getresponse=false,$delayresponse=0,$seekstr=null){
		$this->completeKeys .= $str;

		if(!$this->fp){
			// while the time away cuz no connection
			echo "no connection";
		}
		else{
			fwrite($this->fp,$str);
			if($seekstr==null){
				if($getresponse&&$delayresponse>0) sleep($delayresponse);
				if($this->debugLevel==2||($this->debugLevel==1&&$getresponse)) {
					$this->getResponse($seekstr);
					$this->debugOutput($str);
				} elseif($getresponse) {
					$this->getResponse();
				}
			}
			else{
				echo "looking for $seekstr<br>\n";
				if($getresponse){
					$timeout = 30;
					$found = false;
					$originalStart = $start = time();
					if($delayresponse =0) $delayresponse = 2;
					do{
						$this->getResponse($delayresponse);
						if(!$found && $this->screenCheck($seekstr)){
							$found = true;
							$timeout = (time()-$start)+1; // stop within the next second
						}
						if(!$found && time() < ($originalStart + $timeout) && $this->screenCheck("X SYSTEM")){
							$start = time(); // reset start while the X SYSTEM button is on
							if($this->debugLevel==2)
								echo "resetting start time\n";
						}
						$nowtime = time() - $start;
						if($this->debugLevel==2)
							echo "Waiting for $nowtime > $timeout \n";
					}while((time() - $start) < $timeout);
				}
				if($this->debugLevel==2||($this->debugLevel==1&&$getresponse)) {
					$this->debugOutput($str);
				}
			}
		}
	}
	
	/**
	 * used to pass special keys to telnet such as function keys
	 *
	 * @param string $key
	 * @param bool $getresponse
	 * @param bool $flushbuffer
	 */
	function key($key,$getresponse=false,$delayresponse=0){
		$this->write(constant($key),$getresponse,$delayresponse);
	}
	/**
	 * getResponse processes the responses from the AS
	 * 
	 * 
	 *
	 * @param string $seekstr : look for this str, if it appears, then done with getting a response
	 */
	function getResponse($timeout=20){
		$data = "";
		$start = time();
		if($this->fp){
			do {
				$pass = fgets($this->fp);
				$data .= $pass;	
			} while (($pass!=""||$data=="")&&(time()-$start)<$timeout);
		}
		$this->completeStream .= $this->stream = $data;
		$this->updateScreen();
	}
	
	
	function get3Response(){
		//if($_SERVER['OS']=='Windows_NT') sleep(2); //usleep doesn't work on windows machines
		//else usleep(100000);

//		$data = "";
//		$ctr = 0;
//		while(substr($data,-1)!="H"){
//			$ctr ++;
//			$pass = fgets($this->fp,5);
//			
//			if($pass!="") echo "\n".$ctr.":".$pass;
//			$data .= $pass;
//		}

		$data = "";
		$ctr = 0;
		do{
			
			$pass = fread($this->fp,4024);
			if($pass!=""){
//				echo "\n".$ctr.":".$pass;
				$data .= $pass;
				$ctr = 0;
			} else $ctr ++;

		} while(substr($data,-1)!="H"||$ctr<6000);

//		$pass = fread($this->fp,5);
		
	//	if($pass!="") echo "\npacket returned:".$pass;
		
		$this->completeStream .= $this->stream = $data;
		
//		sleep(1);		

//		;

				
		$this->updateScreen();
	}
	
	function updateScreen(){
		$data = explode(chr(27)."[",$this->stream);
		
		foreach ($data as $val){
			$this->parseCommand($val);
		}
	}
	
	/**
	 * checks to see if $str is found in the stream. Sets jdatelnet::message if string is found and a 2nd paramater is passed.
	 *
	 * @param string $str
	 * @param message $message
	 * @return bool
	 */
	function streamCheck($str,$message=''){
		if(strpos($this->stream,$str)){
			$this->message = $message;
			return true;
		} else  {
			return false;
		}
	}
	
	/**
	 * checks to see if $str is found in the screen. Sets jdatelnet::message if string is found and a 2nd paramater is passed.
	 *
	 * @param string $str
	 * @param message $message
	 * @return bool
	 */
	function screenCheck($str,$message=''){
		
		if(strpos($this->screen,$str)){
			$this->message = $message;
			return true;
		} else  {
			return false;
		}
	}
	
	/**
	 * private method: outputs the command and resulting stream/screen. called by write when jdatelnet::debug is true
	 *
	 * @param unknown_type $command
	 */
	function debugOutput($command){
		if(substr($command,0,1)==chr(27)){
			echo "<br>\n".date("h:i:s ")."Key Sent:[".$this->keys[$command]."] ";
		} else {
			echo "<br>\n".date("h:i:s ")."Key Sent:".$command;
		}
		echo "\r\n";
//		echo chr(13).chr(10)."Raw Stream Returned:".$this->stream.chr(13).chr(10).chr(13).chr(10);
		
//		$lastchar = substr($this->stream,-1,1);
//		echo chr(13).chr(10)."Last Character is:".ord($lastchar).":".$lastchar.chr(13).chr(10).chr(13).chr(10);
		echo $this->getScreen().chr(13).chr(10).chr(13).chr(10);
	}
	
	/**
	 * Closes the telnet connection
	 *
	 */
	function close(){
		fclose($this->fp);	
	}
	
	/**
	 * Enter description here...
	 *
	 * @param int $start
	 * @param int $length
	 * @return string
	 */
	function parsestream($start,$length){
		return trim(substr($this->stream,$start,$length));		
	}
	
	function parseCommand($str){
//		echo $str."\r\n";
		$params = "";
		$command = "";
		
		$len = strlen($str);	
		
		for($i=0;$i<$len;$i++){	
			$char = substr($str,$i,1);
			if(ord($char)>63){
				$params = substr($str,0,$i);
				$command = $char;
				break;
			}
		}
		$this->doCommand($command,$params);
		$string = substr($str,$i+1);
//		if($command=="m"&&$params=="7") $string = str_replace(" ","#",$string);
//		elseif($command=="m"&&$params=="4") $string = " ".substr(str_replace(" ","_",$string),1);
//		elseif($command=="m"&&$params=="4") $string = substr($string,0,1).str_replace(" ","_",substr($string,1));
		$this->screenWrite($string);
	}
	
	function getCursor(){
		//return array('row'=>floor($this->pos/80),'col'=>bcmod($this->pos,80));
		$col = $this->pos % 80;
		return array('row'=>floor($this->pos/80),'col'=>$col);
	}
	
	function doCommand($c,$p){
		$params = explode(";",$p);
		switch ($c){
			
			// erase sequences
			case "J":
				if($params[0]==2) $this->screen = str_repeat(" ",2000); // clear entire screen
				elseif($params[0]==1) $this->screen = substr_replace($this->screen,str_repeat(" ",$this->pos),0,$this->pos); //clear screen before cursor
				elseif($params[0]==0) $this->screen = substr_replace($this->screen,str_repeat(" ",2000-$this->pos),$this->pos,2000-$this->pos); // clear screen after cursor
			break;
			case "@"://Insert n blank spaces
			
			
			break;
			case "K"://Erase line: after cursor (n=0), before cursor (n=1), or entirely (n=2).
			
			
			break;
			case "L"://Insert n new blank lines
			
			
			break;
			case "M"://Delete n lines from cursor
			
			
			break;
			case "P"://Delete n characters from cursor
			
			
			break;
			
			
			
			//cursor movement
			case "G"://Move cursor to column x
			$params[1] = $params[0];
			$params[0] = ceil($this->pos/80);
			case "H"://Move cursor to column x, row y
			case "f"://Move cursor to column x, row y
//				echo $c."(".$p.")\r\n";
				if(!isset($params[1])) $params[1] = 1;
				$this->pos = ($params[0]-1)*80 + $params[1] - 1;
			break;
			case "A"://Move cursor up n lines
				$this->pos -= $params[0]*80;
			break;
			case "B"://Move cursor down n lines
				$this->pos += $params[0]*80;
			break;
			case "C"://Move cursor forward n spaces
				$this->pos += $params[0];
			break;
			case "D"://Move cursor backward n spaces
				$this->pos -= $params[0];
			break;
			case "d"://Move cursor to row y

			break;
//			default:
//				echo $c."(".$p.")\r\n";
//			break;
		}

	}
	
	function maxChars($str,$max){
		if(strlen($str)>=$max) return substr($str,0,$max);
		else return $str.FIELDEXIT;
	}
	
	function screenWrite($str){
//		echo "POS:".$this->pos."	str:".$str."|"."	strlen:".strlen($str)."\r\n";
		$this->screen = substr_replace($this->screen,$str,$this->pos,strlen($str));
		$this->pos += strlen($str);
	}
	
	function getScreen($singleLine=false){
		if($singleLine==true) return $this->screen;
		else {
			$i = 0;
			$str = "";
			while($i<2000){
				$str .= substr($this->screen,$i,80)."\n";
				$i += 80;
			}
			return $str;
		}
	}
	
	function getScreenRow($x){
		$rows = explode("\n",$this->getScreen());
		
		return $rows[$x];
	}
	
	function getScreenSection($row,$start,$len){
		return trim(substr($this->getScreenRow($row),$start,$len));
	}
	
	function writeItems($startRow,$endRow,$start,$length,$selectedCodes,$backtoStart){
		if(!is_array($selectedCodes)) return;
		$totalcounter = 0;

		while(count($selectedCodes)>0&&$totalcounter<6){ // loop for as long as there are still unmatched codes
			$totalcounter ++;
			if($notfirst){
				$this->write(PGDN,true); // scroll to next set
				// do we need to move the cursor back up?
				
			} else $notfirst = true; // set variable for next loop
			
			$rows = explode("\n",$this->getScreen());
			
			for($i=$startRow;$i<=$endRow;$i++){
				if(count($selectedCodes)==0) break;
				$code = trim(substr($rows[$i],$start,$length));
//				echo "CODE FOUND IS ".$code;
//				echo "\r\n\r\n";
//				$key = array_search($code, $selectedCodes);

				if(isset($selectedCodes[$code])){ // match is found. hit x key and remove code from array selectedCodes
//				echo $selectedCodes[$code];
//				echo "\r\n\r\n";
					$this->write($selectedCodes[$code]); 
					unset($selectedCodes[$code]);
//					array_splice($selectedCodes,$key,1);
					if($i==$endRow){ // do key strokes to move back up
						$this->write($backtoStart);
					}
				} elseif($i==$endRow) { // if last row and item is not to be selected... do key strokes to move back up
					for($j=$endRow;$j>$startRow;$j--){ // hit the up key as many times as there are rows
						$this->write(UP);
					}
				} else { // if items is not to be selected then move down to next item.
					$this->write(DOWN);
				}
				//print_r($selectedCodes);
			}
		}
	}

	
	function display($screen,$width=80){
		global $scrCounter;
		$scrCounter++;
		printf("%04d",$scrCounter);
		for($i = 4; $i<$width; $i++){
			echo "-";
		}
		echo "\n";
		print_r(chunk_split($screen,$width));
		
		for($i = 0; $i<$width; $i++){
			echo "-";
		}
		echo "\n";
	}
	
	function show()
	{
		$this->display($this->screen);
	}
}

?>